
# Prerequisite

This demo assumes you have configured Istio with multicluster agents.  Follow the
instructions [here](/istio-ecosystem/wharf-multicluster-sync/tree/master/docs/install/README.md)

# Demo

First, install Bookinfo with _details_ and _productpage_ on cluster1.
The _reviews_ (v1) will be on cluster2

```sh
kubectl --context $CLUSTER1 apply -f bookinfo-norating-noreviews.yaml
kubectl --context $CLUSTER1 apply -f bookinfo-gateway.yaml
kubectl --context $CLUSTER2 apply -f bookinfo-reviews-v1.yaml
```

![Unconnected Bookinfo](bookinfo-unconnected.png?raw=true "Unconnected Bookinfo")

## Before the services are connected

Follow [these instructions](https://istio.io/docs/examples/bookinfo/#determining-the-ingress-ip-and-port) to set the base URL (`$GATEWAY_URL`) to the ingress gateway on Cluster1.

Browse to _http://`${GATEWAY_URL}`/productpage_ to verify that bookinfo you can load the main Bookinfo page.  
Please notice that the book details are present but not reviews as the reviews service is currently not accessible.

![Unconnected UI](ui-unconnected.png?raw=true "Unconnected UI")

## Expose reviews-v1 on cluster2 to cluster1

Create a `ServiceExpositionPolicy` to expose _reviews-v1_ on _cluster2_ to services on _cluster1_:

```sh
kubectl --context $CLUSTER2 apply -f reviews-exposure.yaml
```

The policy we are applying looks like:

```yaml
## Expose the "reviews" service
apiVersion: multicluster.istio.io/v1alpha1
kind: ServiceExpositionPolicy
metadata:
  name: reviews
spec:
  exposed:
  - name: reviews
    port: 9080
```

It just says to expose _reviews:9080_ to all clusters, all namespaces, within our Root CA.

Upon running the above command the agent created Istio configuration on _Cluster2_.  Verify that
the configuration was created:

```sh
kubectl --context $CLUSTER2 get gateways,virtualservices,destinationrules
```

You should see a gateway, virtual service, and destination rule for reviews.

The topology is now:

![Bookinfo with reviews v1](bookinfo-reviews-v1.png?raw=true "Bookinfo with reviews v1")

## Inspect the binding on cluster 1

Exposing a service on _cluster2_ caused a `RemoteServiceBinding` to be created on _cluster1_ by the MC Agent. You can verify by getting it:

```sh
kubectl --context $CLUSTER1 get remoteservicebindings
```

As the binding is now in `live` mode the client-side Istio configuration has also been created automatically. Verify it:

```sh
kubectl --context $CLUSTER1 get service,destinationrule,serviceentry
```

## Verify that the reviews is present in the UI

![Connected UI](ui-connected.png?raw=true "Connected UI")

Reload _http://`${GATEWAY_URL}`/productpage_ in the browser.  Verify that reviews are present.

## Deploying and Exposing the Ratings microservice

We will now deploy a _ratings_ service on cluster1 and expose it.

### Optional: Manually accept configuration

*OPTIONAL*: For this tutorial sub-step we will
show how to configure client-side multicluster agents to run in manual mode.

First, do `kubectl --context $CLUSTER2 edit cm mc-configuration`.  Change `ConnectionMode: live`
to `ConnectionMode: potential` and save.

Note that it may take up to 30 seconds before the change to potential mode takes effect on the agent.  You may wish to do a `sleep 30` to making changes too quickly.

## Deploy and expose Ratings

```sh
kubectl --context $CLUSTER1 apply -f bookinfo-ratings.yaml
kubectl --context $CLUSTER1 apply -f ratings-exposure.yaml
```

### Optional: Make configuration live

*ONLY PERFORM IF DID OPTIONAL 'potential' STEP ABOVE*: For this tutorial sub-step we will
show how listing of potential remote services and making them live.

First, verify that a new RemoteServiceBinding was created on $CLUSTER2 after the service
on $CLUSTER1 was created

```sh
kubectl --context $CLUSTER2 get remoteservicebindings
kubectl --context $CLUSTER2 edit remoteservicebinding cluster1-services
```

Change `connection: potential`
to `connection: live` and save.  The agent will create the configuration.  The following
step will show it.

## Verify configuration generated by live binding

As before, exposing ratings created configuration on peer cluster2:

```sh
kubectl --context $CLUSTER2 get service,destinationrule,serviceentry
```

## Deploying a new version of reviews that will consume ratings

We will now deploy.  There is no need to expose this version of reviews.  The exposure
of the _reviews_ *Service* exposed all pods of all versions.  The new version will be added
to the normal round-robin.
 
```sh
kubectl --context $CLUSTER2 apply -f bookinfo-reviews-v2.yaml
```

![Bookinfo with Stars](ui-stars.png?raw=true "Bookinfo with Stars")

(The stars only appear if v2 of the _reviews_ service can contact _ratings_ to determine
the number of stars.)

The final version of the cross-cluster configuration includes communication between all three
clusters.

![Bookinfo with reviews v2 and ratings](bookinfo-ratings.png?raw=true "Bookinfo with reviews v2 and ratings")


# Cleanup

To remove the demo artifacts, execute the following:

```sh
kubectl --context $CLUSTER2 delete -f reviews-exposure.yaml
kubectl --context $CLUSTER1 delete service reviews
kubectl --context $CLUSTER1 delete -f ratings-exposure.yaml
kubectl --context $CLUSTER2 delete service ratings
kubectl --context $CLUSTER1 delete -f bookinfo-norating-noreviews.yaml
kubectl --context $CLUSTER1 delete -f bookinfo-gateway.yaml
kubectl --context $CLUSTER2 delete -f bookinfo-reviews-v1.yaml
kubectl --context $CLUSTER2 delete -f bookinfo-reviews-v2.yaml
kubectl --context $CLUSTER1 delete -f bookinfo-ratings.yaml
```
