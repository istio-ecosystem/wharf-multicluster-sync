// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: multicluster/v1alpha1/remote_service_binding.proto

/*
	Package v1alpha1 is a generated protocol buffer package.

	It is generated from these files:
		multicluster/v1alpha1/remote_service_binding.proto
		multicluster/v1alpha1/service_exposition_policy.proto

	It has these top-level messages:
		RemoteServiceBinding
		ServiceExpositionPolicy
*/
package v1alpha1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// `RemoteServiceBinding` describes an the remote clusters that the local
// cluster can access along with the remote services exposed by those remote
// clusters. The information in this model allows binding a remote service for
// the use within local mesh.
//
// The following example has a remote service FooA from clusterC mapped into a
// local service called `remoteFooA` within the `istio-remote` namespace.
// Another remote service `FooB` from clusterD is available by its original
// remote name and in the default namespace.
//
// ```yaml
// apiVersion: multicluster.istio.io/v1alpha1
// kind: RemoteServiceBinding
// metadata:
//   name: sample1
//   namespace: mynamespace
// spec:
//   remote:
//   - cluster: clusterC
//     services:
//     - name: FooA
//       alias: remoteFooA
//       namespace: istio-remote
//   - cluster: clusterD
//     services:
//     - name: FooB
// ```
type RemoteServiceBinding struct {
	// REQUIRED: One or more remote (donor) clusters that provides remote
	// services to be used by local cluster. It is a list of cluster IDs and the
	// remote service from each cluster that will be binded to local mesh
	// services.
	Remote []*RemoteServiceBinding_RemoteCluster `protobuf:"bytes,1,rep,name=remote" json:"remote,omitempty"`
}

func (m *RemoteServiceBinding) Reset()         { *m = RemoteServiceBinding{} }
func (m *RemoteServiceBinding) String() string { return proto.CompactTextString(m) }
func (*RemoteServiceBinding) ProtoMessage()    {}
func (*RemoteServiceBinding) Descriptor() ([]byte, []int) {
	return fileDescriptorRemoteServiceBinding, []int{0}
}

func (m *RemoteServiceBinding) GetRemote() []*RemoteServiceBinding_RemoteCluster {
	if m != nil {
		return m.Remote
	}
	return nil
}

// Each remote cluster has an entry in the `RemoteServiceBinding`. As cluster
// IDs are unique we don't expect two entries with the same name in a single
// binding resource.
type RemoteServiceBinding_RemoteCluster struct {
	// REQUIRED: The remote cluster ID (aka donor cluster).
	Cluster string `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	// A list of remote service from the donor cluster to be binded into local
	// services.
	Services []*RemoteServiceBinding_RemoteCluster_RemoteService `protobuf:"bytes,2,rep,name=services" json:"services,omitempty"`
}

func (m *RemoteServiceBinding_RemoteCluster) Reset()         { *m = RemoteServiceBinding_RemoteCluster{} }
func (m *RemoteServiceBinding_RemoteCluster) String() string { return proto.CompactTextString(m) }
func (*RemoteServiceBinding_RemoteCluster) ProtoMessage()    {}
func (*RemoteServiceBinding_RemoteCluster) Descriptor() ([]byte, []int) {
	return fileDescriptorRemoteServiceBinding, []int{0, 0}
}

func (m *RemoteServiceBinding_RemoteCluster) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *RemoteServiceBinding_RemoteCluster) GetServices() []*RemoteServiceBinding_RemoteCluster_RemoteService {
	if m != nil {
		return m.Services
	}
	return nil
}

// Each exposed service by the donor cluster has a `RemoteService` entry.
type RemoteServiceBinding_RemoteCluster_RemoteService struct {
	// REQUIRED: The name of the exposed remote service.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This is an alias that can be used for the local name of the remote
	// service. It allows the operator to use a custom service name which
	// may not match the remote name. This is an optional field. If not
	// specified, the local binded service name will be named like the
	// remote service name.
	Alias string `protobuf:"bytes,2,opt,name=alias,proto3" json:"alias,omitempty"`
	// A destination namespace where the binded service will be added to.
	Namespace string `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *RemoteServiceBinding_RemoteCluster_RemoteService) Reset() {
	*m = RemoteServiceBinding_RemoteCluster_RemoteService{}
}
func (m *RemoteServiceBinding_RemoteCluster_RemoteService) String() string {
	return proto.CompactTextString(m)
}
func (*RemoteServiceBinding_RemoteCluster_RemoteService) ProtoMessage() {}
func (*RemoteServiceBinding_RemoteCluster_RemoteService) Descriptor() ([]byte, []int) {
	return fileDescriptorRemoteServiceBinding, []int{0, 0, 0}
}

func (m *RemoteServiceBinding_RemoteCluster_RemoteService) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RemoteServiceBinding_RemoteCluster_RemoteService) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *RemoteServiceBinding_RemoteCluster_RemoteService) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func init() {
	proto.RegisterType((*RemoteServiceBinding)(nil), "istio.multicluster.v1alpha1.RemoteServiceBinding")
	proto.RegisterType((*RemoteServiceBinding_RemoteCluster)(nil), "istio.multicluster.v1alpha1.RemoteServiceBinding.RemoteCluster")
	proto.RegisterType((*RemoteServiceBinding_RemoteCluster_RemoteService)(nil), "istio.multicluster.v1alpha1.RemoteServiceBinding.RemoteCluster.RemoteService")
}
func (m *RemoteServiceBinding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteServiceBinding) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Remote) > 0 {
		for _, msg := range m.Remote {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRemoteServiceBinding(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RemoteServiceBinding_RemoteCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteServiceBinding_RemoteCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cluster) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRemoteServiceBinding(dAtA, i, uint64(len(m.Cluster)))
		i += copy(dAtA[i:], m.Cluster)
	}
	if len(m.Services) > 0 {
		for _, msg := range m.Services {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRemoteServiceBinding(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RemoteServiceBinding_RemoteCluster_RemoteService) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteServiceBinding_RemoteCluster_RemoteService) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRemoteServiceBinding(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Alias) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRemoteServiceBinding(dAtA, i, uint64(len(m.Alias)))
		i += copy(dAtA[i:], m.Alias)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRemoteServiceBinding(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	return i, nil
}

func encodeVarintRemoteServiceBinding(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RemoteServiceBinding) Size() (n int) {
	var l int
	_ = l
	if len(m.Remote) > 0 {
		for _, e := range m.Remote {
			l = e.Size()
			n += 1 + l + sovRemoteServiceBinding(uint64(l))
		}
	}
	return n
}

func (m *RemoteServiceBinding_RemoteCluster) Size() (n int) {
	var l int
	_ = l
	l = len(m.Cluster)
	if l > 0 {
		n += 1 + l + sovRemoteServiceBinding(uint64(l))
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovRemoteServiceBinding(uint64(l))
		}
	}
	return n
}

func (m *RemoteServiceBinding_RemoteCluster_RemoteService) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRemoteServiceBinding(uint64(l))
	}
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovRemoteServiceBinding(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovRemoteServiceBinding(uint64(l))
	}
	return n
}

func sovRemoteServiceBinding(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRemoteServiceBinding(x uint64) (n int) {
	return sovRemoteServiceBinding(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RemoteServiceBinding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRemoteServiceBinding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteServiceBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteServiceBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRemoteServiceBinding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRemoteServiceBinding
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remote = append(m.Remote, &RemoteServiceBinding_RemoteCluster{})
			if err := m.Remote[len(m.Remote)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRemoteServiceBinding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRemoteServiceBinding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteServiceBinding_RemoteCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRemoteServiceBinding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRemoteServiceBinding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRemoteServiceBinding
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cluster = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRemoteServiceBinding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRemoteServiceBinding
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &RemoteServiceBinding_RemoteCluster_RemoteService{})
			if err := m.Services[len(m.Services)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRemoteServiceBinding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRemoteServiceBinding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteServiceBinding_RemoteCluster_RemoteService) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRemoteServiceBinding
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteService: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteService: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRemoteServiceBinding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRemoteServiceBinding
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRemoteServiceBinding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRemoteServiceBinding
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRemoteServiceBinding
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRemoteServiceBinding
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRemoteServiceBinding(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRemoteServiceBinding
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRemoteServiceBinding(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRemoteServiceBinding
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRemoteServiceBinding
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRemoteServiceBinding
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRemoteServiceBinding
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRemoteServiceBinding
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRemoteServiceBinding(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRemoteServiceBinding = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRemoteServiceBinding   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("multicluster/v1alpha1/remote_service_binding.proto", fileDescriptorRemoteServiceBinding)
}

var fileDescriptorRemoteServiceBinding = []byte{
	// 287 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x91, 0xb1, 0x4e, 0xc3, 0x30,
	0x14, 0x45, 0xe5, 0x16, 0x0a, 0x35, 0x62, 0xb1, 0x3a, 0x44, 0x05, 0x45, 0x15, 0x53, 0x97, 0xda,
	0x6a, 0xf9, 0x00, 0xa4, 0xb2, 0xc2, 0x12, 0x86, 0x4a, 0x5d, 0x2a, 0x27, 0xb5, 0x9a, 0x27, 0xc5,
	0x71, 0x64, 0x3b, 0xfd, 0x46, 0x46, 0xfe, 0x00, 0x94, 0x9d, 0x7f, 0x40, 0xb1, 0x1d, 0x68, 0xa5,
	0x8a, 0xa5, 0x9b, 0xfd, 0xee, 0xbb, 0x47, 0xf7, 0xea, 0xe1, 0x85, 0xac, 0x0b, 0x0b, 0x59, 0x51,
	0x1b, 0x2b, 0x34, 0xdb, 0xcf, 0x79, 0x51, 0xe5, 0x7c, 0xce, 0xb4, 0x90, 0xca, 0x8a, 0x8d, 0x11,
	0x7a, 0x0f, 0x99, 0xd8, 0xa4, 0x50, 0x6e, 0xa1, 0xdc, 0xd1, 0x4a, 0x2b, 0xab, 0xc8, 0x1d, 0x18,
	0x0b, 0x8a, 0x1e, 0x3a, 0x69, 0xe7, 0x7c, 0xf8, 0xec, 0xe1, 0x51, 0xe2, 0xdc, 0x6f, 0xde, 0xbc,
	0xf4, 0x5e, 0xb2, 0xc2, 0x03, 0x4f, 0x8d, 0xd0, 0xa4, 0x3f, 0xbd, 0x59, 0x3c, 0xd1, 0x7f, 0x30,
	0xf4, 0x14, 0x22, 0x0c, 0x9f, 0xfd, 0x6e, 0x12, 0x70, 0xe3, 0x6f, 0x84, 0x6f, 0x8f, 0x14, 0x12,
	0xe1, 0xab, 0x00, 0x8c, 0xd0, 0x04, 0x4d, 0x87, 0x49, 0xf7, 0x25, 0x80, 0xaf, 0x43, 0x27, 0x13,
	0xf5, 0x5c, 0x8c, 0xd7, 0x33, 0x63, 0x1c, 0xaf, 0x24, 0xbf, 0xf8, 0xf1, 0xaa, 0x4b, 0x15, 0x24,
	0x42, 0xf0, 0x45, 0xc9, 0xa5, 0x08, 0x91, 0xdc, 0x9b, 0x8c, 0xf0, 0x25, 0x2f, 0x80, 0xb7, 0x61,
	0xda, 0xa1, 0xff, 0x90, 0x7b, 0x3c, 0x6c, 0x55, 0x53, 0xf1, 0x4c, 0x44, 0x7d, 0xa7, 0xfc, 0x0d,
	0x96, 0xeb, 0xf7, 0x26, 0x46, 0x1f, 0x4d, 0x8c, 0xbe, 0x9a, 0x18, 0xad, 0x5f, 0x76, 0x60, 0xf3,
	0x3a, 0xa5, 0x90, 0x4a, 0x9a, 0x29, 0xc9, 0x5c, 0x9b, 0x99, 0x16, 0x46, 0x70, 0x9d, 0xe5, 0xec,
	0xb0, 0xd6, 0x4c, 0x2b, 0xbe, 0x95, 0xbc, 0x62, 0xbc, 0x02, 0x76, 0xf2, 0xee, 0xe9, 0xc0, 0x5d,
	0xf8, 0xf1, 0x27, 0x00, 0x00, 0xff, 0xff, 0x9a, 0x35, 0x28, 0x21, 0x17, 0x02, 0x00, 0x00,
}
